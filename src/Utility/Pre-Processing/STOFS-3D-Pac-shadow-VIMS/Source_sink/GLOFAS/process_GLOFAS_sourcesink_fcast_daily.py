from pylib import read,inside_polygon
import numpy as np
import netCDF4 as nc
import matplotlib.pyplot as plt
import os
import datetime
import argparse
import cdsapi
######################################
# model time range from param.nml
parser = argparse.ArgumentParser(description='''Download and process GLOFAS forecast for source_sink files, uses preprocessed glofas location information.
        example: python process_GLOFAS_sourcesink_fcast_daily.py preproc tmp 2025-02-05 5 --imagedir ./ --regionfiles lewis_larger.reg''')
parser.add_argument(dest='glofasdir', type=str, help='location of preproc-glofas.npz')
parser.add_argument(dest='outdir', type=str, help='location to write source_sink files')
parser.add_argument(dest='startdate', type=str, help='run start YYYY-MM-DD')
parser.add_argument(dest='rnday', type=int, help='length of run in days')
parser.add_argument('-r','--regionfiles',dest='regfiles', type=str, default=None, help='regions where GLOFAS inputs should be ignore, comma separated list. GLOFAS inputs at open boundaries are automatically ignored')
#regfiles = ['lewis_larger.reg',]
parser.add_argument('-i','--imagedir',dest='imagedir', type=str, default=None, help='location to place sanity check images, no images generated by default')
args = parser.parse_args()
glofasdir = args.glofasdir # location of preproc-glofas.npz
outdir = args.outdir # source_sink files written here
#param = pl.read(paramfile)
#modelstartdate = datetime.datetime(int(param['start_year']), int(param['start_month']),int(param['start_day']))
#rnday = int(param['rnday'])
mdate = [int(x) for x  in args.startdate.split('-')]
modelstartdate = datetime.datetime(mdate[0],mdate[1],mdate[2])
rnday = args.rnday
imagedir = args.imagedir # source_sink files written here
if imagedir is None:
    processplot = False
else:
    processplot = True
if args.regfiles is None:
    regfiles = []
else:
    regfiles = args.regfiles.split(',')

# plotting areas for sanity checks
plotbounds = {'Columbia':[235.5,238,44.5,47.5],'VancIs':[231,237, 48.25, 52.1]}
plotarea = 'VancIs'

preproc = np.load(os.path.join(glofasdir,'preproc-glofas.npz'),allow_pickle=True)
Erivers=preproc["Erivers"];idxs=preproc["idxs"];ind0N=preproc["ind0N"];ind1N=preproc["ind1N"]; lonN=preproc["lonN"];latN=preproc["latN"];lon=preproc["lon"];lat=preproc["lat"];areaN=preproc["areaN"];final=preproc["final"]
xctr = preproc["xctr"]
yctr= preproc["yctr"]
elnode = preproc["elnode"]
iobn =  preproc["iobn"]
x = preproc["x"]
y = preproc["y"]
ne = preproc["ne"]

bnds = [np.max(y)+1,np.min(x)-1,np.min(y)-1,np.max(x)+1]
# download GLOFAS forecast data

dataset = "cems-glofas-forecast"
request = {
    "system_version": ["operational"],
    "hydrological_model": ["lisflood"],
    "product_type": ["control_forecast"],
    "variable": "river_discharge_in_the_last_24_hours",
    "year": [mdate[0]],
    "month": [mdate[1]],
    "day": [mdate[2]],
    "leadtime_hour": [ '%s' % (24*d) for d in range(1,rnday)
    ],
    "data_format": "netcdf",
    "download_format": "unarchived",
    "area": bnds
}

fname = os.path.join(outdir,'GLOFAS-today-full.nc')
client = cdsapi.Client(url='https://ewds.climate.copernicus.eu/api')
req = client.retrieve(dataset, request, fname)
print(f'downloaded {fname}')

outsuffix = f'forecast'
modelenddate = modelstartdate + datetime.timedelta(days=rnday)

plotbounds = {'Columbia':[235.5,238,44.5,47.5],'VancIs':[231,237, 48.25, 52.1]}

# read in spatial subsets of GLOFAS data
riverCoordsSubset = np.zeros((Erivers.shape[0],2))
ncid = nc.Dataset(fname)
p0 = np.searchsorted(lat, ncid.variables['latitude'][0], sorter=np.arange(len(lat)-1, -1, -1)) # lat is in decreasing order 
p1 = np.searchsorted(lon, ncid.variables['longitude'][0]) -1
print(p0,p1,lon,lat,ncid.variables['latitude'][0], ncid.variables['longitude'][0] )
ind0N_sub = ind0N - (len(lat)-p0)
ind1N_sub = ind1N -p1
g = np.where(np.logical_and.reduce((ind0N_sub>=0, ind1N_sub>=0, ind0N_sub < ncid.variables['latitude'].shape[0], ind1N_sub < ncid.variables['longitude'].shape[0])))[0]
print(f'found {g.shape} locations in area, out of {ind0N.shape}')
Rlon = ncid.variables['longitude'][ind1N_sub[g]]
Rlat = ncid.variables['latitude'][ind0N_sub[g]]
riverCoordsSubset[g,:] = np.c_[Rlon,Rlat]
T = ncid.variables['valid_time'][:]
time_units = ncid.variables['valid_time'].units
GLOFASstart = datetime.datetime.strptime(time_units,'seconds since %Y-%m-%dT%H:%M:%S')
GLOFASreftime = ncid.variables['forecast_reference_time'][0] 
relmodstart = (modelstartdate - GLOFASstart).total_seconds()
relmodend = (modelenddate - GLOFASstart).total_seconds()
timeind = np.argwhere(np.logical_and(T>=relmodstart,T<=relmodend)).ravel()
discharge = np.zeros((timeind.shape[0],ind0N.shape[0])) * np.nan
T = T[timeind]-relmodstart
dis24 = ncid.variables['dis24'][timeind,0,:,:]
for i in g:
  discharge[:,i] = dis24[:,ind0N_sub[i],ind1N_sub[i]]

# max discharge used for sanity check plotting 
maxdischarge = np.max(discharge,axis=0)
# test plot showing successful alignment of main grid and subgrid methods
if processplot:
  f,ax = plt.subplots(1,1)
  ax.plot(riverCoordsSubset[:,0],riverCoordsSubset[:,1],'+m')
  #gdf.plot(ax=ax,color='cyan')
  c = ax.scatter(lonN,latN,np.log2(areaN)*8,np.log10(areaN))
  plt.colorbar(c,label='log2 watershed area')
  ax.axis(plotbounds[plotarea])
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_watershedarea.png'))
  f,ax = plt.subplots(1,1)
  ax.plot(riverCoordsSubset[:,0],riverCoordsSubset[:,1],'+m')
  #gdf.plot(ax=ax,color='cyan')
  c = ax.scatter(lonN,latN,np.log2(maxdischarge)*8,np.log10(maxdischarge))
  plt.colorbar(c,label='log2 discharge')
  ax.plot(xctr[Erivers],yctr[Erivers],'kd')
  ax.axis(plotbounds[plotarea])
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_end.png'))
  dx = [1,10, 100,500,1e6]
  cs = ['y','c','g','b','r']
  plt.close(f)
  f,ax = plt.subplots(1,1)
  try:
     print(g.shape,areaN.shape)
     for i in range(len(dx)-1):
       gb =  np.logical_and.reduce((g,areaN[g]>=dx[i], areaN[g]<dx[i+1]))
       ax.plot(T/86400,np.sum(discharge[:,g[gb]],axis=1),c=cs[i],label=f'{dx[i]} - {dx[i+1]}')
     ax.legend(title=f'discharge range in {plotarea}')
     ax.set_xlabel('days')
     ax.set_ylabel('Q (m^3/s)')
     f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_discharge_by_area.png'))
     plt.close(f)
     f,ax = plt.subplots(1,1)
     for i in range(len(dx)-1):
       gb =  np.logical_and.reduce((g,areaN[g]>=dx[i], areaN[g]<dx[i+1]))
       ax.plot(np.sum(areaN[g[gb]]),np.max(np.sum(discharge[:,g[gb]],axis=1)),c=cs[i],label=f'{dx[i]} - {dx[i+1]}',marker='.')
     ax.legend(title=f'discharge range in {plotarea}')
     ax.set_xlabel('area (km)')
     ax.set_ylabel('max Q (m^3/s)')
     f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_mxdischarge_vs_area.png'))
  except ValueError:
     print('error in mxdischarge plots')
     pass

# this gives the element to which to assign the river
# write source-sink.in 
# merge river values from duplicate elements
uniqErivers, uniqEriversInd, DeuniqEriversInd, uniqEriversCount = np.unique(Erivers,return_index=True, return_inverse=True, return_counts=True)
dups = np.where(uniqEriversCount>1)[0]
singles = np.where(uniqEriversCount==1)[0]
dischargeE = np.zeros((discharge.shape[0],uniqErivers.shape[0]))
dischargeE[:,singles] = discharge[:,uniqEriversInd[singles]]
for d in dups:
   ind = np.where(Erivers == uniqErivers[d])[0]
   for i in ind:
       dischargeE[:,d] += discharge[:,i]

# need to remove rivers near open boundaries (mostly an issue for river open boundaries, but probably also good for ocean open boundaries
Enodes = elnode[uniqErivers,:]
openbnd = np.array([],dtype=int)
for b in iobn :
   Eind = np.argwhere(np.any(np.isin(Enodes,b),axis=1))
   if len(Eind)>0:
       openbnd = np.r_[openbnd,Eind.ravel()[:]]

# also need to loop over regions to manually remove any rivers that aren't caught by the automated method (e.g. Lewis River in Pacific model)
# read regions from list of regions
ctr = np.c_[xctr[uniqErivers],yctr[uniqErivers]]
for r in regfiles:
   reg = read(r)
   # find Ecenters in  region polygon and add elements to openbnd list
   Eind = np.argwhere(inside_polygon(ctr,reg.x,reg.y))
   if len(Eind)>0:
       openbnd = np.r_[openbnd,Eind[0][:]]

dischargeE = np.delete(dischargeE,openbnd,axis=1)
uniqErivers = np.delete(uniqErivers,openbnd)

empty = np.unique(np.argwhere(np.isnan(dischargeE))[:,1])
if empty.shape[0]>0:
   # write vsource.bp as sanity check
  props = np.zeros((empty.shape[0],4))
  props[:,0] = np.arange(empty.shape[0])+1
  props[:,1:3] = np.c_[xctr[uniqErivers[empty]],yctr[uniqErivers[empty]]]
  with open(os.path.join(outdir,f'{outsuffix}empty_rivers.bp'),'w') as f:
    f.write('GLOFAS river locations not covered in data files\n%s\n' % props.shape[0])
    np.savetxt(f,props,fmt='%d %.8f %.8f %.1f')
  dischargeE[:,empty] = 0  # fill missing rivers with 0 flow to avoid null values in .th files

# could implement the redistribute inflow method here, but can also use fortran code on files generated here

# write output files containing 1-indexed list of elements source_sink.in, source_sink.prop file, and source_sink.bp file (2nd and 3rd for testing)
with open(os.path.join(outdir,f'{outsuffix}source_sink.in'),'w') as f:
  f.write('%d\n' % len(uniqErivers))
  np.savetxt(f,uniqErivers+1,fmt='%d')
  f.write('\n')
  f.write('0\n')

# write vsource.th from discharge and valid_time (converted to seconds since start of run)
vsource = np.c_[T,dischargeE]
with open(os.path.join(outdir,f'{outsuffix}vsource.th'),'w') as f:
  np.savetxt(f,dischargeE)

# write msource.th from discharge and valid_time (converted to seconds since start of run)
salval = 0 
msource = np.c_[T,dischargeE*0+salval,dischargeE[:,1:]*0-999]
with open(os.path.join(outdir,f'{outsuffix}msource.th'),'w') as f:
  np.savetxt(f,dischargeE)

# write vsource.prop as sanity check
props = np.zeros((ne,2),dtype = int)
props[:,0] = np.arange(ne)+1
props[uniqErivers,1] = (np.round(np.max(dischargeE,axis=0))).astype(int)
with open(os.path.join(outdir,f'{outsuffix}vsource.prop'),'w') as f:
  np.savetxt(f,props,fmt='%d')

# write vsource.bp as sanity check
props = np.zeros((len(uniqErivers),4))
props[:,0] = np.arange(len(uniqErivers))+1
props[:,1:3] = np.c_[xctr[uniqErivers],yctr[uniqErivers]]
props[:,3] = np.max(dischargeE,axis=0)
with open(os.path.join(outdir,f'{outsuffix}vsource.bp'),'w') as f:
  f.write('GLOFAS river locations\n%s\n' % props.shape[0])
  np.savetxt(f,props,fmt='%d %.8f %.8f %.1f')

xuniq = xctr[uniqErivers]
yuniq = yctr[uniqErivers]
if processplot:
  vanc = np.where(np.logical_and.reduce((xuniq > plotbounds[plotarea][0],xuniq<plotbounds[plotarea][1], yuniq >plotbounds[plotarea][2], yuniq < plotbounds[plotarea][3])))[0]
  f,ax = plt.subplots(1,1)
  ax.plot(T,dischargeE[:,vanc],c='grey')
  ax.set_title(f'GLOFAS discharge around {plotarea}')
  ax.set_ylabel('discharge (m^3/s')
  ax.set_xlabel('seconds')
  f.savefig(os.path.join(imagedir,f'glofas_{plotarea}_{outsuffix}_tseries.png'))
  plt.close(f)
